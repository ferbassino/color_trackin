<!DOCTYPE html>
<html lang="en">
  <head>
    <!-- <meta charset="UTF-8" /> -->
    <!-- <meta name="viewport" content="width=device-width, initial-scale=1.0" /> -->
    <!-- <link rel="stylesheet" href="styles.css" /> -->
    <!-- <title>Document</title> -->
    <script
      src="https://cdn.plot.ly/plotly-2.32.0.min.js"
      charset="utf-8"
    ></script>
  </head>
  <body>
    <div>
      <div class="menu">
        <a href="/index.html">Home</a>
        <a href="/white_tracker.html">Upload video</a>
        <a href="/tracking.html">Real Time</a>
        <a href="/white_tracker_analysis.html">Analysis</a>
        <!-- <a href="#">Servicios</a>
        <a href="#">Contacto</a> -->
      </div>
      <canvas id="myChart"></canvas>
    </div>
    <div class="right">
      <div id="tester" style="width: 600px; height: 250px"></div>
    </div>

    <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>

    <script>
      var array = JSON.parse(localStorage.getItem("array"));
      var fps = JSON.parse(localStorage.getItem("fps"));
      var duration = JSON.parse(localStorage.getItem("duration"));
      // ingresamos la calibración
      const pixelEnMetros = 0.0022;

      const data = {
        datasets: [
          {
            label: "Scatter Dataset",
            data: array,
            backgroundColor: "rgb(255, 99, 132)",
          },
        ],
      };
      console.log(array);
      // dividir en grupos de a tres
      function splitIntoGroups(array) {
        const groups = [];
        let currentGroup = [];

        for (let i = 0; i < array.length; i++) {
          if (
            currentGroup.length === 0 ||
            Math.abs(
              array[i].milliseconds -
                currentGroup[currentGroup.length - 1].milliseconds
            ) <= 10
          ) {
            currentGroup.push(array[i]);
          } else {
            groups.push(currentGroup);
            currentGroup = [array[i]];
          }
        }

        if (currentGroup.length > 0) {
          groups.push(currentGroup);
        }

        return groups;
      }
      function checkGroups(groups) {
        for (const group of groups) {
          for (let i = 1; i < group.length; i++) {
            if (
              Math.abs(group[i].milliseconds - group[i - 1].milliseconds) > 50
            ) {
              return false;
            }
          }
        }
        return true;
      }

      let groups = splitIntoGroups(array);
      while (!checkGroups(groups)) {
        groups = splitIntoGroups(array);
      }
      const alpha = [array[0]];
      const beta = [array[1]];
      const gamma = [array[2]];
      const lambda = [array[3]];
      const epsilon = [array[4]];
      let dif = [];

      for (let i = 5; i < array.length - 1; i++) {
        let lastPositionArray = [
          alpha[alpha.length - 1],
          beta[beta.length - 1],
          gamma[gamma.length - 1],
          lambda[lambda.length - 1],
          epsilon[epsilon.length - 1],
        ];

        dif = [
          Math.abs(lastPositionArray[0].x - array[i].x) +
            Math.abs(lastPositionArray[0].y - array[i].y),
          Math.abs(lastPositionArray[1].x - array[i].x) +
            Math.abs(lastPositionArray[1].y - array[i].y),
          Math.abs(lastPositionArray[2].x - array[i].x) +
            Math.abs(lastPositionArray[2].y - array[i].y),
          Math.abs(lastPositionArray[3].x - array[i].x) +
            Math.abs(lastPositionArray[3].y - array[i].y),
          Math.abs(lastPositionArray[4].x - array[i].x) +
            Math.abs(lastPositionArray[4].y - array[i].y),
        ];

        let min = Math.min(...dif);

        if (min === dif[0]) {
          alpha.push(array[i]);
        }

        if (min === dif[1]) {
          beta.push(array[i]);
        }
        if (min === dif[2]) {
          gamma.push(array[i]);
        }
        if (min === dif[3]) {
          lambda.push(array[i]);
        }
        if (min === dif[4]) {
          epsilon.push(array[i]);
        }
      }

      console.log(
        alpha.length,
        beta.length,
        gamma.length,
        lambda.length,
        epsilon.length
      );
      // ------------------------------groups------------
      const el = [
        { x: 291, y: 590, milliseconds: 1717380326188 },
        { x: 360, y: 397, milliseconds: 1717380326188 },
        { x: 303, y: 195, milliseconds: 1717380326188 },
      ];
      const VerticalVector = [0, el[0].y - el[1].y];
      const hipDopProduct = (el[0].y - el[1].y) * (el[0].y - el[1].y);
      const VericalModule = Math.sqrt(Math.pow(Math.pow(el[0].y - el[1].y, 2)));

      const musloVector = [el[0].x - el[1].x, el[0].y - el[1].y];
      const piernaVector = [el[2].x - el[1].x, el[2].y - el[1].y];
      const dotProduct =
        (el[0].x - el[1].x) * (el[2].x - el[1].x) +
        (el[0].y - el[1].y) * (el[2].y - el[1].y);
      const musloModule = Math.sqrt(
        Math.pow(el[0].x - el[1].x, 2) + Math.pow(el[0].y - el[1].y, 2)
      );
      const piernaModule = Math.sqrt(
        Math.pow(el[1].x - el[2].x, 2) + Math.pow(el[1].y - el[2].y, 2)
      );

      // angles----------------
      const hipAngle = [];
      const kneeAngle = [];
      const ankleAngle = [];

      for (let index = 0; index < alpha.length - 10; index++) {
        kneeAngle.push(
          (Math.acos(
            ((beta[index].x - alpha[index].x) *
              (gamma[index].x - beta[index].x) +
              (beta[index].y - alpha[index].y) *
                (gamma[index].y - beta[index].y)) /
              (Math.sqrt(
                Math.pow(alpha[index].x - beta[index].x, 2) +
                  Math.pow(alpha[index].y - beta[index].y, 2)
              ) *
                Math.sqrt(
                  Math.pow(beta[index].x - gamma[index].x, 2) +
                    Math.pow(beta[index].y - gamma[index].y, 2)
                ))
          ) *
            180) /
            Math.PI
        );
        ankleAngle.push(
          (Math.acos(
            ((epsilon[index].x - lambda[index].x) *
              (gamma[index].x - beta[index].x) +
              (epsilon[index].y - lambda[index].y) *
                (gamma[index].y - beta[index].y)) /
              (Math.sqrt(
                Math.pow(epsilon[index].x - lambda[index].x, 2) +
                  Math.pow(epsilon[index].y - lambda[index].y, 2)
              ) *
                Math.sqrt(
                  Math.pow(beta[index].x - gamma[index].x, 2) +
                    Math.pow(beta[index].y - gamma[index].y, 2)
                ))
          ) *
            180) /
            Math.PI
        );

        hipAngle.push(
          ((Math.asin(
            (alpha[index].x - beta[index].x) /
              Math.sqrt(
                Math.pow(alpha[index].x - beta[index].x, 2) +
                  Math.pow(alpha[index].y - beta[index].y, 2)
              )
          ) *
            180) /
            Math.PI) *
            -1
        );
      }

      // tiempo

      const timeArray = [];
      let timeCount = 0;
      for (let i = 0; i < groups.length - 1; i++) {
        timeArray.push(
          (timeCount +=
            groups[i + 1][0].milliseconds - groups[i][0].milliseconds) / 1000
        );
      }
      console.log("cuadros originales: ", fps, "fps");

      console.log("tiempo total en slow: ", duration / 1000, "s");
      const realTime = ((duration / 1000) * fps) / 240;
      console.log("tiempo corregido a 240", realTime, "s");

      const correctedInterval = realTime / groups.length;
      console.log("intervalo", correctedInterval);

      let intervalArray = [];
      let intervalCount = 0;
      groups.map((el) => {
        intervalCount += correctedInterval;
        intervalArray.push(Number(intervalCount.toFixed(3)));
      });
      // ----------------------------

      // ------------------ gota
      const alphaX = [];
      const alphaY = [];
      alpha.map((el) => {
        alphaX.push(el.x);
        alphaY.push(el.y);
      });
      const betaX = [];
      const betaY = [];
      beta.map((el) => {
        betaX.push(el.x);
        betaY.push(el.y);
      });
      const gammaX = [];
      const gammaY = [];
      gamma.map((el) => {
        gammaX.push(el.x);
        gammaY.push(el.y);
      });
      const lambdaX = [];
      const lambdaY = [];
      lambda.map((el) => {
        lambdaX.push(el.x);
        lambdaY.push(el.y);
      });
      const epsilonX = [];
      const epsilonY = [];
      epsilon.map((el) => {
        epsilonX.push(el.x);
        epsilonY.push(el.y);
      });

      console.log(alphaY[0] - betaY[0]);
      // -------------------- fin gota

      const alphaY0 = [];
      const alphaYFirstValue = alphaY[0];
      alphaY.map((el) => {
        alphaY0.push(el - alphaYFirstValue);
      });

      // modificar el valor entre los intervalos

      function modificarValoresIntermedios(arr) {
        const result = [];
        let currentGroup = [arr[0]];

        for (let i = 1; i <= arr.length; i++) {
          if (arr[i] === arr[i - 1]) {
            // Continuamos agregando al grupo actual
            currentGroup.push(arr[i]);
          } else {
            // Detectamos el final del grupo
            const groupLength = currentGroup.length;
            const increment = (arr[i] - currentGroup[0]) / (groupLength + 1);

            // Calculamos los valores intermedios y los agregamos al resultado
            for (let j = 1; j < groupLength; j++) {
              result.push(Number((currentGroup[0] + j * increment).toFixed(2)));
            }
            // Agregamos el valor final del grupo
            result.push(arr[i]);

            // Reiniciamos el grupo actual
            currentGroup = [arr[i]];
          }
        }

        return result;
      }

      // Ejemplo de uso:

      const resultado = modificarValoresIntermedios(alphaY0);

      // -----------------derivada para velocidad------------------

      function interpolacionPolinomicaDerivada(pixeles, intervaloTiempo) {
        const n = pixeles.length;
        const h = intervaloTiempo;

        const derivada = [];
        for (let i = 1; i < n - 1; i++) {
          const f_i1 = pixeles[i + 1];
          const f_i_1 = pixeles[i - 1];
          const derivada_i = (f_i1 - f_i_1) / (2 * h);
          derivada.push(derivada_i);
        }

        return derivada;
      }

      // Ejemplo de uso:

      const derivadaResultante = interpolacionPolinomicaDerivada(
        alphaY0,
        correctedInterval
      );

      // filtro de savitzkyGolay

      function savitzkyGolay(datos, ventana, gradoPolinomio) {
        // Asegurémonos de que la ventana sea impar
        if (ventana % 2 === 0) {
          ventana++;
        }

        const mitadVentana = Math.floor(ventana / 2);
        const coeficientes = [];

        // Calculamos los coeficientes del polinomio de ajuste
        for (let i = -mitadVentana; i <= mitadVentana; i++) {
          const coef = [];
          for (let j = 0; j <= gradoPolinomio; j++) {
            coef.push(Math.pow(i, j));
          }
          coeficientes.push(coef);
        }

        // Aplicamos el filtro Savitzky-Golay
        const suavizado = [];
        for (let i = mitadVentana; i < datos.length - mitadVentana; i++) {
          let suma = 0;
          for (let j = -mitadVentana; j <= mitadVentana; j++) {
            suma += coeficientes[j + mitadVentana][0] * datos[i + j];
          }
          suavizado.push(suma);
        }

        return suavizado;
      }

      const ventana = 5; // Tamaño de la ventana (debe ser impar)
      const gradoPolinomio = 2; // Grado del polinomio de ajuste (puedes ajustarlo según tus necesidades)
      const datosSuavizados = savitzkyGolay(
        derivadaResultante,
        ventana,
        gradoPolinomio
      );
      console.log("Datos suavizados:", datosSuavizados);

      // -------------fin derivada de la posición
      function interpolacionPolinomicaDerivada(pixeles, intervaloTiempo) {
        const n = pixeles.length;
        const h = intervaloTiempo;

        const derivada = [];
        for (let i = 1; i < n - 1; i++) {
          const f_i1 = pixeles[i + 1];
          const f_i_1 = pixeles[i - 1];
          const derivada_i = (f_i1 - f_i_1) / (2 * h);
          derivada.push(derivada_i);
        }

        return derivada;
      }

      // Ejemplo de uso:

      const yAcceleration = interpolacionPolinomicaDerivada(
        datosSuavizados,
        correctedInterval
      );
      // derivada de la velocidad

      const ctx = document.getElementById("myChart");

      // new Chart(ctx, {
      //   type: "line",
      //   data: {
      //     labels: intervalArray,
      //     datasets: [
      //       {
      //         label: "knee",
      //         data: resultado,
      //         borderWidth: 1,
      //       },
      //       {
      //         label: "knee",
      //         data: datosSuavizados,
      //         borderWidth: 1,
      //       },
      //       {
      //         label: "knee",
      //         data: yAcceleration,
      //         borderWidth: 1,
      //       },
      //     ],
      //   },
      //   options: {
      //     scales: {
      //       y: {
      //         beginAtZero: true,
      //       },
      //     },
      //   },
      // });
      new Chart(ctx, {
        type: "line",
        data: {
          labels: intervalArray,
          datasets: [
            {
              label: "knee",
              data: kneeAngle,
              borderWidth: 1,
            },
            {
              label: "hip",
              data: hipAngle,
              borderWidth: 1,
            },
            {
              label: "ankle",
              data: ankleAngle,
              borderWidth: 1,
            },
          ],
        },
        options: {
          scales: {
            y: {
              beginAtZero: true,
            },
          },
        },
      });
      TESTER = document.getElementById("tester");
      var layout = {
        width: 1000,
        height: 800,
        xaxis: { range: [0, 1.5] },
        yaxis: { range: [0, 2] },
      };

      Plotly.newPlot(
        TESTER,
        [
          {
            x: alphaX,
            y: alphaY,
            type: "scatter",
            mode: "markers",
            marker: {
              size: 2,
            },
          },
          {
            x: betaX,
            y: betaY,
            type: "scatter",
            mode: "markers",
            marker: {
              size: 2,
            },
          },
          // {
          //   x: gammaX,
          //   y: gammaY,
          //   type: "scatter",
          //   mode: "markers",
          //   marker: {
          //     size: 1,
          //   },
          // },
          // {
          //   x: lambdaX,
          //   y: lambdaY,
          //   type: "scatter",
          //   mode: "markers",
          //   marker: {
          //     size: 2,
          //   },
          // },
          {
            x: epsilonX,
            y: epsilonY,
            type: "scatter",
            mode: "markers",
            marker: {
              size: 4,
            },
          },
        ],
        layout,

        {
          margin: { t: 0 },
        }
      );
    </script>
  </body>
</html>
